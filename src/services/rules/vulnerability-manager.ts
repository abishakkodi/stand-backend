import { supabaseAdmin } from '../../config/supabase.js';
import { Vulnerability, MitigationOption, AssessmentObservation, MitigationType, MitigationValue } from './types.js';

export class VulnerabilityManager {
  async getVulnerabilityMitigationOptions(vulnerabilityId: string): Promise<MitigationOption[]> {
    const { data: vulnerability } = await supabaseAdmin
      .from('vulnerabilities')
      .select('mitigation_type_id')
      .eq('id', vulnerabilityId)
      .single();

    if (!vulnerability?.mitigation_type_id) {
      return [];
    }

    // First get the mitigation type
    const { data: mitigationType } = await supabaseAdmin
      .from('mitigation_types')
      .select('*')
      .eq('id', vulnerability.mitigation_type_id)
      .single();

    if (!mitigationType) {
      return [];
    }

    // Then get the mitigation values
    const { data: mitigationValues } = await supabaseAdmin
      .from('mitigation_values')
      .select('id, description, category')
      .eq('mitigation_type_id', vulnerability.mitigation_type_id);

    if (!mitigationValues) {
      return [];
    }

    // Format the response
    return [{
      id: mitigationType.id,
      type: {
        id: mitigationType.id,
        name: mitigationType.name,
        description: mitigationType.description,
        value_type: mitigationType.value_type,
        multiple: mitigationType.multiple
      },
      values: mitigationValues.map(value => ({
        id: value.id,
        description: value.description,
        category: value.category
      }))
    }];
  }

  async applyMitigation(
    vulnerabilityId: string,
    mitigationValueId: string,
    description: string
  ): Promise<{ vulnerability: Vulnerability; mitigation: MitigationValue }> {
    // Update the vulnerability
    const { data: vulnerability } = await supabaseAdmin
      .from('vulnerabilities')
      .update({
        status: 'in_review',
        mitigation_value_id: mitigationValueId,
        mitigation_description: description,
        updated_at: new Date().toISOString()
      })
      .eq('id', vulnerabilityId)
      .select()
      .single();

    if (!vulnerability) {
      throw new Error('Failed to update vulnerability');
    }

    // Get the mitigation details
    const { data: mitigation } = await supabaseAdmin
      .from('mitigation_values')
      .select('id, description, category')
      .eq('id', mitigationValueId)
      .single();

    if (!mitigation) {
      throw new Error('Failed to fetch mitigation details');
    }

    return {
      vulnerability,
      mitigation: {
        id: mitigation.id,
        description: mitigation.description,
        category: mitigation.category
      }
    };
  }

  async updateStatus(vulnerabilityId: string, status: 'open' | 'in_review' | 'resolved', notes?: string): Promise<Vulnerability> {
    const { data, error } = await supabaseAdmin
      .from('vulnerabilities')
      .update({
        status,
        notes,
        updated_at: new Date().toISOString()
      })
      .eq('id', vulnerabilityId)
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to update vulnerability status: ${error.message}`);
    }

    return data;
  }

  async getVulnerabilityObservations(vulnerability: Vulnerability): Promise<AssessmentObservation[]> {
    const { data: assessment } = await supabaseAdmin
      .from('assessments')
      .select('observations')
      .eq('id', vulnerability.assessment_id)
      .single();

    return assessment?.observations || [];
  }

  async createVulnerability(ruleId: string, assessmentId: string, propertyId: number): Promise<void> {
    const { error } = await supabaseAdmin
      .from('vulnerabilities')
      .insert({
        rule_id: ruleId,
        assessment_id: assessmentId,
        property_id: propertyId,
        status: 'open',
        detected_at: new Date().toISOString()
      });

    if (error) {
      throw new Error(`Failed to create vulnerability: ${error.message}`);
    }
  }
} 